properties:


  - name: node
    type: YAML::Node
    constructor_arg: true
    init_with: '{}'
    getter: true
    setter: true


functions:


  - name: parse
    type: Blast::Cpp::EnumClass
    body: |
      Blast::Cpp::EnumClass result;

      // This is the schema:

      //- name: State
        //scope: protected
        //include_undef_item: true (default)
        //to_string_func: true (default)
        //from_string_func: true (default)
        //to_int_func: false (default)
        //from_int_func: false (default)
        //items:
          //- RUNNING
          //- HIDING

      // Validate presence and type
      bool class_node_is_present = (bool)node["class"];
      if (class_node_is_present) validate_node_type(node, "class", YAML::NodeType::Scalar);
      bool name_node_is_present = (bool)node["name"];
      if (name_node_is_present) validate_node_type(node, "name", YAML::NodeType::Scalar);
      bool type_node_is_present = (bool)node["type"];
      if (type_node_is_present) validate_node_type(node, "type", YAML::NodeType::Scalar);

      validate_presence_of_key(node, "enumerators");
      validate_node_type(node, "enumerators", YAML::NodeType::Sequence);

      // Extract the "class" and/or "name" value, along with the "is_class" property
      if (name_node_is_present && class_node_is_present)
      {
         std::stringstream error_message;
         error_message << "[Blast::Quinetessence::YAMLParsing::EnumClassParser::parse]: error: "
                       << "An enum cannot have both the \"name\" and \"class\" present. It must be one or neither.";
                       // TODO: look into the Mark() function in YAML, which should(?) provide data about the line
                       // number of the node
         throw std::runtime_error(error_message.str());
      }
      else if (class_node_is_present)
      {
         result.set_name(node["class"].as<std::string>());
         result.set_is_class(true);
      }
      else if (name_node_is_present)
      {
         result.set_name(node["name"].as<std::string>());
      }

      // Extract the "type" value
      if (type_node_is_present) result.set_type(node["type"].as<std::string>());

      // Extract the "enumerators" elements
      std::vector<std::string> enum_enumerators;
      YAML::Node enumerators_node = node["enumerators"];
      validate_unique_all_upper_identifiers(enumerators_node);
      for (std::size_t i=0; i<enumerators_node.size(); i++)
      {
         // TODO: validate elements are all std::string and are of valid format (all caps, underscores, unique)
         std::string enum_item = enumerators_node[i].as<std::string>();
         enum_enumerators.push_back(enum_item);
      }

      // Set the "enumerators" values
      result.set_enumerators(enum_enumerators);

      return result;


  - name: validate_presence_of_key
    static: true
    type: bool
    parameters:
      - name: node
        type: YAML::Node
        default_argument: '{}'
      - name: key
        type: std::string
        default_argument: '"[unset-key]"'
      - name: throw_on_error
        type: bool
        default_argument: true
    body: |
      // TODO: test this function
      if (node[key]) return true;

      if (throw_on_error)
      {
         std::stringstream error_message;
         error_message << "[Blast::Quinetessence::YAMLParsing::EnumClassParser::validate_presence_of_key]: error: "
                       << "expecting to find node \"" << key << "\" but it is not present.";
         throw std::runtime_error(error_message.str());
      }
      return false;


  - name: validate_node_type
    static: true
    type: bool
    parameters:
      - name: node
        type: YAML::Node
        default_argument: '{}'
      - name: key
        type: std::string
        default_argument: '"[unset-key]"'
      - name: expected_type
        type: YAML::NodeType::value
        default_argument: YAML::NodeType::Undefined
      - name: throw_on_error
        type: bool
        default_argument: true
    body: |
      if (node[key].Type() == expected_type) return true;

      // TODO: test these validators
      if (throw_on_error)
      {
         std::string name_of_type = yaml_node_type_as_string(expected_type);
         std::stringstream error_message;
         error_message << "[Blast::Quinetessence::YAMLParsing::EnumClassParser::validate_node_type]: error: "
                       << "expecting to find node \"" << key << "\" as a \"" << name_of_type << "\", "
                       << "but it is a \"" << node[key] << "\".";
         throw std::runtime_error(error_message.str());
      }
      return false;


  - name: validate_elements_are_unique
    static: true
    type: bool
    parameters:
      - name: elements
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      // TODO: test this function
      std::unordered_set<std::string> unique_set;
      for (const auto& element : elements)
      {
         if (!unique_set.insert(element).second)
         {
             return false;
         }
      }
      return true;
    body_dependency_symbols:
      - std::unordered_set


  - name: yaml_node_type_as_string
    static: true
    type: std::string
    parameters:
      - name: node_type
        type: YAML::NodeType::value
        default_argument: YAML::NodeType::Undefined
    body: |
      // TODO: test this function
      switch(node_type)
      {
         case YAML::NodeType::Null: return "Null"; break;
         case YAML::NodeType::Scalar: return "Scalar"; break;
         case YAML::NodeType::Sequence: return "Sequence"; break;
         case YAML::NodeType::Map: return "Map"; break;
         case YAML::NodeType::Undefined: return "Undefined"; break;
         default: {
            std::stringstream error_message;
            error_message << "[Blast::Quinetessence::YAMLParsing::EnumClassParser::yaml_node_type_as_string]: error: "
                          << "Unhandled case for type \"" << node_type << "\"";
            throw std::runtime_error(error_message.str());
         } break;
      }
      return "";


  - name: validate_unique_all_upper_identifiers
    static: true
    type: bool
    parameters:
      - name: items
        type: YAML::Node
        default_argument: '{}'
    body: |
      // TODO: add exception messages to areas with return false
      if (!items.IsSequence())
      {
         std::string node_type_as_string = yaml_node_type_as_string(items["items"].Type());
         std::stringstream error_message;
         error_message
           << "Expecting node \"items\" to be a \"Sequence\" but it was a \""
           << node_type_as_string
           << "\".";

         Blast::Errors::throw_error(
           "Blast::Quinetessence::YAMLParsing::EnumClassParser::validate_unique_all_upper_identifiers",
           error_message.str()
         );

         return false;
      }

      // Check that each string in the list meets the requirements
      for (const auto& item : items) {
         if (!item.IsScalar()) {
            return false;
         }

         const std::string& str = item.as<std::string>();
         if (str.empty() || !std::isupper(str[0])) {
            return false;
         }

         for (char c : str) {
            if (!std::isalnum(c) && c != '_') {
              return false;
            }
         }

         if (std::any_of(str.begin() + 1, str.end(), [](char c) { return std::isdigit(c); })) {
            return false;
         }
       }

       // All checks passed
       return true;
    body_dependency_symbols:
      - Blast::Errors


dependencies:


  - symbol: YAML::Node
    headers: [ yaml-cpp/yaml.h ]
  - symbol: YAML::NodeType::value
    headers: [ yaml-cpp/yaml.h ]
  - symbol: Blast::Cpp::EnumClass
    headers: [ Blast/Cpp/EnumClass.hpp ]
  - symbol: Blast::Errors
    headers: [ Blast/Errors.hpp ]



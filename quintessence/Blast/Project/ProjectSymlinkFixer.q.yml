functions:
  - name: starts_with
    private: true
    type: bool
    parameters:
      - name: source
        type: std::string
        default_argument: "\"\""
      - name: string_to_find
        type: std::string
        default_argument: "\"\""
    body: |
      return source.rfind(string_to_find, 0) == 0;



  - name: line_count
    type: int
    parameters:
      - name: filename
        type: std::string
        default_argument: "\"\""
    body: |
      std::ifstream myfile(filename);

      // new lines will be skipped unless we stop it from happening:
      myfile.unsetf(std::ios_base::skipws);

      // count the newlines with an algorithm specialized for counting:
      unsigned line_count = std::count(
            std::istream_iterator<char>(myfile),
            std::istream_iterator<char>(),
            '\n');

      //std::cout << "Lines: " << line_count << "\n";}
      return line_count;
    body_dependency_symbols:
      - std::ifstream


  - name: read_file_firstline
    type: std::string
    parameters:
      - name: filename
        type: std::string
        default_argument: "\"\""
    body: |
      std::ifstream infile(filename);

      std::string sLine;
      if (infile.good())
      {
         getline(infile, sLine);
      }
      else
      {
         throw std::runtime_error("Unexpected error in read_file_firstline");
      }

      infile.close();

      return sLine;


  - name: likely_an_intended_symlink
    private: true
    type: bool
    parameters:
      - name: filename
        type: std::string
        default_argument: "\"\""
      - name: string_to_find
        type: std::string
        default_argument: "\"\""
    body: |
      std::ifstream infile(filename);
      bool starts_with_string = false;

      if (infile.good())
      {
         std::string sLine;
         getline(infile, sLine);
         //std::cout << sLine << std::endl;
         if (starts_with(sLine, string_to_find)) starts_with_string = true;
         if (starts_with(sLine, "../") && line_count(filename) == 1) starts_with_string = true;
      }

      infile.close();

      return starts_with_string;


  - name: read_symlink
    type: std::string
    parameters:
      - name: filename
        type: std::string
        default_argument: "\"\""
    body: |
      namespace fs = std::filesystem;
      std::string symlink_target;
      try
      {
         symlink_target = fs::read_symlink(std::filesystem::path(filename)).string();
      }
      catch (const std::exception& e)
      {
         symlink_target = read_file_firstline(filename);
      }
      return symlink_target;



  - name: run
    type: void
    body: |
      namespace fs = std::filesystem;

      //const std::string MAGIC_STRING = "/Users/markoates/Repos/";
      const std::string MAGIC_STRING = "../../../";
      std::vector<std::string> filenames = {};
      for(auto& p: fs::recursive_directory_iterator("."))
      {
         std::string filename = p.path().string();
         std::replace(filename.begin(), filename.end(), '\\', '/');
         std::cout << filename << std::endl;

         if (fs::is_symlink(p) || likely_an_intended_symlink(filename, MAGIC_STRING))
         {
            std::cout << "   LIKELY" << std::endl;
            filenames.push_back(filename);
            std::string symlink_target = read_symlink(filename);
            std::string sanitized_target = symlink_target;
            if (starts_with(symlink_target, MAGIC_STRING))
            {
               // this means it's a hard-coded target path
               // TODO: make this ../../../ instead count the proper number of "../" elements to prefix
               sanitized_target.replace(0, std::string(MAGIC_STRING).length(), "../../../");
               std::cout << "!!!!!";
            }

            fs::remove(p.path());
            try
            {
               fs::create_symlink(sanitized_target, p.path());
            }
            catch (const std::exception& e)
            {
               std::cout << "Caught error when attempting to fs::create_symlink: " << e.what() << std::endl;
               std::cout << "Attempting alternative link creation with shell command" << std::endl;

               std::stringstream command;
               command << "ln -sf " << sanitized_target << " " << filename;
               Blast::ShellCommandExecutorWithCallback executor(command.str());
               executor.execute();
               //create_symlink(sanitized_target, p.path());

               //p.path().string() << " -> " << sanitized_target << '\n';
               //error
            }
            std::cout << p.path().string() << " -> " << sanitized_target << '\n';
         }
      }
    body_dependency_symbols:
      - std::vector<std::string>
      - std::stringstream
      - std::cout
      - std::endl
      - Blast::ShellCommandExecutorWithCallback



dependencies:
  - symbol: Blast::ShellCommandExecutorWithCallback
    headers: [ Blast/ShellCommandExecutorWithCallback.hpp ]
  - symbol: std::cout
    headers: [ iostream ]
  - symbol: std::endl
    headers: [ iostream ]
  - symbol: std::ifstream
    headers: [ fstream ]

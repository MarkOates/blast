
# Programs

## `create_source_release`

This program will create a "source release" version of any Blast-based project. This can be helpful for hack-a-thons where you need to create a quick compilation of the current project's files, and don't have time to sort out symlinks, data files, Makefiles, and the like.

#### Configuring a Target Project to Build

To use, you'll need to setup some configuration in the executable, recompile, then you can call the executable from anywhere.

Right now, the project to be assembled into a release is hard-coded by name in the executable, so you'll need to modify the executable and recompile before you should run it.

Note the "project name" is identical to the root folder name of the project as located in the `Users/markoates/Repos/` folder.  So, if the project is "`Flowers`" (a project from a recent hack-a-thon), then the "`project_name`" variable in the `create_source_release.cpp` program source file should be assigned the string value `"Flowers"`.

```
   std::string project_name = "Flowers";
```

Recompile, then run the executable.  Upon running, the executable will place a new `Release/` folder on your desktop, and within it another folder called `ProjectNameSourceRelease/`, where `ProjectName` is the name of the project as set in the executable. (So, in the above example, `FlowersSourceRelease/` is generated).

#### Makefile and Build
 This releaser program assumes that a program source file for the project exists in the project's `programs/` folder with the same name as the project, and is the primary executable to run the project. (So, a `programs/Flowers.cpp` exists in the `Flowers/` project folder).

The releaser program, in addition to generating all the required source files, also generates a `Makefile` that will be placed in the release folder.  Upon envoking `make` while in the source release folder, Make will compile the `Flowers.cpp` program as a "`Flowers`" executable file  in the root of the release folder, while including all the source files and linking to the required Allegro libraries.

_You shouldn't expect to include the compiled project executable with the release, but it wouldn't hurt to test it out, give it a run, and then delete it before you zip up the contents of the release folder and send it out to whomever needs the source release._

This program delegates entirely to the `Blast::Project::SourceReleaseBuilder` component
and calls `generate_source_release()`.


## Add a Symlink with `symlink_component_from_another_project`

Symlinks are used as the primary technique to reference components from other repos in a project's source tree.  This is done in order to maintain synchronicity with component versions across projects.

If possible, symlinks should be created from the quintessence file, so that the generated files can be created by the build system in that project's directory directly.  If a quintessence file is not available for that  component, then you'll want to create symlinks of the header and source files.  Test files do not need to be included.

To create a symlink, use the `symlink_component` from the command line (an alias to the `symlink_component_from_another_project` from the `blast` project).

* You can run `symlink_component` with no arguments and it will output an error message with instructions on usage.
* Note that the `symlink_component` program is safe to execute and will have no side effects other than outputting to stdout.
* You must the commands generated by `symlink_component` in the directory of the project where you want the new components to be.

When running `symlink_component`, pass the project name that contains the source component, followed by a component name.

For example:

```
> symlink_component allegro_flare AllegroFlare/Vec3D
```
The above command will generate the symlink commands (one per line) and dump them to the terminal as raw text:

```
TARGET_PROJECT=allegro_flare; COMPONENT=AllegroFlare/Vec3D; mkdir -p ./quintessence/AllegroFlare && ln -s ../../../${TARGET_PROJECT}/quintessence/${COMPONENT}.q.yml ./quintessence/${COMPONENT}.q.yml; unset COMPONENT; unset TARGET_PROJECT
TARGET_PROJECT=allegro_flare; COMPONENT=AllegroFlare/Vec3D; mkdir -p ./tests/AllegroFlare && ln -s ../../../${TARGET_PROJECT}/tests/${COMPONENT}Test.cpp ./tests/${COMPONENT}Test.cpp; unset COMPONENT; unset TARGET_PROJECT
TARGET_PROJECT=allegro_flare; COMPONENT=AllegroFlare/Vec3D; mkdir -p ./src/AllegroFlare && ln -s ../../../${TARGET_PROJECT}/src/${COMPONENT}.cpp ./src/${COMPONENT}.cpp; mkdir -p ./include/AllegroFlare && ln -s ../../../${TARGET_PROJECT}/include/${COMPONENT}.hpp ./include/${COMPONENT}.hpp; unset COMPONENT; unset TARGET_PROJECT
```

* The first command, when executed, will symlink the quintessence file only
* The second command will symlink the test file (if you wish to symlink it). Sometimes this can be helpful if you want to develop symlinked components outside their native project, though it is recommended that you enter into the source project for the component to make the changes there.
* The third command will symlink the header and source files.

Pick whichever command(s) are necessary for your purpose, copy/paste it, and run it while in the the project's directory.  The new symlinks will appear in your project.  Run `make` (if you symlinked a quintessence file) to generate the header/source files.

Finally, commit the files into your source tree.
